{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isPositiveInteger = require( '@stdlib/assert-is-positive-integer' ).isPrimitive;\nvar isSquareMatrix = require( '@stdlib/assert-is-square-matrix' );\nvar isVectorLike = require( '@stdlib/assert-is-vector-like' );\nvar Float64Array = require( '@stdlib/array-float64' );\nvar format = require( '@stdlib/string-format' );\nvar sqrt = require( '@stdlib/math-base-special-sqrt' );\nvar ctor = require( '@stdlib/ndarray-ctor' );\nvar bctor = require( '@stdlib/ndarray-base-ctor' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\n\n\n// FUNCTIONS //\n\n/**\n* Returns a matrix.\n*\n* @private\n* @param {PositiveInteger} n - matrix order\n* @param {boolean} bool - boolean indicating whether to create a low-level ndarray\n* @returns {ndarray} matrix\n*/\nfunction createMatrix( n, bool ) {\n\tvar strides;\n\tvar buffer;\n\tvar shape;\n\tvar f;\n\n\tif ( bool ) {\n\t\tf = bctor;\n\t} else {\n\t\tf = ctor;\n\t}\n\tbuffer = new Float64Array( n*n );\n\tshape = [ n, n ];\n\tstrides = [ n, 1 ];\n\treturn f( 'float64', buffer, shape, strides, 0, 'row-major' );\n}\n\n/**\n* Sets the values along the main diagonal of a square matrix.\n*\n* @private\n* @param {ndarray} matrix - input square matrix\n* @param {number} v - value\n* @returns {ndarray} input matrix\n*/\nfunction diagonal( matrix, v ) {\n\tvar M = matrix.shape[ 0 ];\n\tvar i;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tmatrix.set( i, i, v );\n\t}\n\treturn matrix;\n}\n\n/**\n* Returns a vector.\n*\n* @private\n* @param {PositiveInteger} N - number of elements\n* @returns {ndarray} vector\n*/\nfunction createVector( N ) {\n\tvar strides;\n\tvar buffer;\n\tvar shape;\n\n\tbuffer = new Float64Array( N );\n\tshape = [ N ];\n\tstrides = [ 1 ];\n\n\treturn bctor( 'float64', buffer, shape, strides, 0, 'row-major' );\n}\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a sample Pearson product-moment correlation matrix.\n*\n* ## Method\n*\n* -   For each sample Pearson product-moment correlation coefficient, we begin by defining the co-moment \\\\(C_{jn}\\\\)\n*\n*     ```tex\n*     C_n = \\sum_{i=1}^{n} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n )\n*     ```\n*\n*     where \\\\(\\bar{x}_n\\\\) and \\\\(\\bar{y}_n\\\\) are the sample means for \\\\(x\\\\) and \\\\(y\\\\), respectively.\n*\n* -   Based on Welford's method, we know the update formulas for the sample means are given by\n*\n*     ```tex\n*     \\bar{x}_n = \\bar{x}_{n-1} + \\frac{x_n - \\bar{x}_{n-1}}{n}\n*     ```\n*\n*     and\n*\n*     ```tex\n*     \\bar{y}_n = \\bar{y}_{n-1} + \\frac{y_n - \\bar{y}_{n-1}}{n}\n*     ```\n*\n* -   Substituting into the equation for \\\\(C_n\\\\) and rearranging terms\n*\n*     ```tex\n*     C_n = C_{n-1} + (x_n - \\bar{x}_n) (y_n - \\bar{y}_{n-1})\n*     ```\n*\n*     where the apparent asymmetry arises from\n*\n*     ```tex\n*     x_n - \\bar{x}_n = \\frac{n-1}{n} (x_n - \\bar{x}_{n-1})\n*     ```\n*\n*     and, hence, the update term can be equivalently expressed\n*\n*     ```tex\n*     \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})\n*     ```\n*\n* -   The covariance can be defined\n*\n*     ```tex\n*     \\begin{align*}\n*     \\operatorname{cov}_n(x,y) &= \\frac{C_n}{n} \\\\\n*     &= \\frac{C_{n-1} + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n} \\\\\n*     &= \\frac{(n-1)\\operatorname{cov}_{n-1}(x,y) + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n}\n*     \\end{align*}\n*     ```\n*\n* -   Applying Bessel's correction, we arrive at an update formula for calculating an unbiased sample covariance\n*\n*     ```tex\n*     \\begin{align*}\n*     \\operatorname{cov}_n(x,y) &= \\frac{n}{n-1}\\cdot\\frac{(n-1)\\operatorname{cov}_{n-1}(x,y) + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n} \\\\\n*     &= \\operatorname{cov}_{n-1}(x,y) + \\frac{(x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n} \\\\\n*     &= \\frac{C_{n-1}}{n-1} + \\frac{(x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n}\n*     &= \\frac{C_{n-1} + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n-1}\n*     \\end{align*}\n*     ```\n*\n* -   To calculate the corrected sample standard deviation, we can use Welford's method, which can be derived as follows. We can express the variance as\n*\n*     ```tex\n*     \\begin{align*}\n*     S_n &= n \\sigma_n^2 \\\\\n*         &= \\sum_{i=1}^{n} (x_i - \\mu_n)^2 \\\\\n*         &= \\biggl(\\sum_{i=1}^{n} x_i^2 \\biggr) - n\\mu_n^2\n*     \\end{align*}\n*     ```\n*\n*     Accordingly,\n*\n*     ```tex\n*     \\begin{align*}\n*     S_n - S_{n-1} &= \\sum_{i=1}^{n} x_i^2 - n\\mu_n^2 - \\sum_{i=1}^{n-1} x_i^2 + (n-1)\\mu_{n-1}^2 \\\\\n*                   &= x_n^2 - n\\mu_n^2 + (n-1)\\mu_{n-1}^2 \\\\\n*                   &= x_n^2 - \\mu_{n-1}^2 + n(\\mu_{n-1}^2 - \\mu_n^2) \\\\\n*                   &= x_n^2 - \\mu_{n-1}^2 + n(\\mu_{n-1} - \\mu_n)(\\mu_{n-1} + \\mu_n) \\\\\n*                   &= x_n^2 - \\mu_{n-1}^2 + (\\mu_{n-1} - x_n)(\\mu_{n-1} + \\mu_n) \\\\\n*                   &= x_n^2 - \\mu_{n-1}^2 + \\mu_{n-1}^2 - x_n\\mu_n - x_n\\mu_{n-1} + \\mu_n\\mu_{n-1} \\\\\n*                   &= x_n^2 - x_n\\mu_n - x_n\\mu_{n-1} + \\mu_n\\mu_{n-1} \\\\\n*                   &= (x_n - \\mu_{n-1})(x_n - \\mu_n) \\\\\n*                   &= S_{n-1} + (x_n - \\mu_{n-1})(x_n - \\mu_n)\n*     \\end{align*}\n*     ```\n*\n*     where we use the identity\n*\n*     ```tex\n*     x_n - \\mu_{n-1} = n (\\mu_n - \\mu_{n-1})\n*     ```\n*\n* -   To compute the corrected sample standard deviation, we apply Bessel's correction and take the square root.\n*\n* -   The sample Pearson product-moment correlation coefficient can thus be calculated as\n*\n*     ```tex\n*     r = \\frac{\\operatorname{cov}_n(x,y)}{\\sigma_x \\sigma_y}\n*     ```\n*\n*     where \\\\(\\sigma_x\\\\) and \\\\(\\sigma_y\\\\) are the corrected sample standard deviations for \\\\(x\\\\) and \\\\(y\\\\), respectively.\n*\n* @param {(PositiveInteger|ndarray)} out - order of the correlation matrix or a square 2-dimensional output ndarray for storing the correlation matrix\n* @param {ndarray} [means] - mean values\n* @throws {TypeError} first argument must be either a positive integer or a 2-dimensional ndarray having equal dimensions\n* @throws {TypeError} second argument must be a 1-dimensional ndarray\n* @throws {Error} number of means must match correlation matrix dimensions\n* @returns {Function} accumulator function\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n*\n* // Create an output correlation matrix:\n* var buffer = new Float64Array( 4 );\n* var shape = [ 2, 2 ];\n* var strides = [ 2, 1 ];\n* var offset = 0;\n* var order = 'row-major';\n*\n* var corr = ndarray( 'float64', buffer, shape, strides, offset, order );\n*\n* // Create a correlation matrix accumulator:\n* var accumulator = incrpcorrmat( corr );\n*\n* var out = accumulator();\n* // returns null\n*\n* // Create a data vector:\n* buffer = new Float64Array( 2 );\n* shape = [ 2 ];\n* strides = [ 1 ];\n*\n* var vec = ndarray( 'float64', buffer, shape, strides, offset, order );\n*\n* // Provide data to the accumulator:\n* vec.set( 0, 2.0 );\n* vec.set( 1, 1.0 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* var bool = ( out === corr );\n* // returns true\n*\n* vec.set( 0, -5.0 );\n* vec.set( 1, 3.14 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* // Retrieve the correlation matrix:\n* out = accumulator();\n* // returns <ndarray>\n*/\nfunction incrpcorrmat( out, means ) {\n\tvar order;\n\tvar corr;\n\tvar M2;\n\tvar sd;\n\tvar mu;\n\tvar C;\n\tvar d;\n\tvar N;\n\n\tN = 0;\n\tif ( isPositiveInteger( out ) ) {\n\t\torder = out;\n\t\tcorr = createMatrix( order, false );\n\t} else if ( isSquareMatrix( out ) ) {\n\t\torder = out.shape[ 0 ];\n\t\tcorr = out;\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must either specify the order of the correlation matrix or be a square two-dimensional ndarray for storing the correlation matrix. Value: `%s`.', out ) );\n\t}\n\t// Set the values along the correlation matrix diagonal to `1` (i.e., a random variable is always perfectly correlated with itself):\n\tcorr = diagonal( corr, 1.0 );\n\n\t// Create a scratch array for storing residuals (i.e., `x_i - xbar_{i-1}`):\n\td = new Float64Array( order );\n\n\t// Create a scratch array for storing second moments:\n\tM2 = new Float64Array( order );\n\n\t// Create a scratch array for storing standard deviations:\n\tsd = new Float64Array( order );\n\n\t// Create a low-level scratch matrix for storing co-moments:\n\tC = createMatrix( order, true );\n\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isVectorLike( means ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a one-dimensional ndarray. Value: `%s`.', means ) );\n\t\t}\n\t\tif ( numel( means.shape ) !== order ) {\n\t\t\tthrow new Error( 'invalid argument. The number of elements (means) in the second argument must match correlation matrix dimensions. Expected: '+order+'. Actual: '+numel( means.shape )+'.' );\n\t\t}\n\t\tmu = means; // TODO: should we copy this? Otherwise, internal state could be \"corrupted\" due to mutation outside the accumulator\n\t\treturn accumulator2;\n\t}\n\t// Create an ndarray vector for storing sample means (note: an ndarray interface is not necessary, but it reduces implementation complexity by ensuring a consistent abstraction for accessing and updating sample means):\n\tmu = createVector( order );\n\n\treturn accumulator1;\n\n\t/**\n\t* If provided a data vector, the accumulator function returns an updated sample correlation matrix. If not provided a data vector, the accumulator function returns the current sample correlation matrix.\n\t*\n\t* @private\n\t* @param {ndarray} [v] - data vector\n\t* @throws {TypeError} must provide a 1-dimensional ndarray\n\t* @throws {Error} vector length must match correlation matrix dimensions\n\t* @returns {(ndarray|null)} sample correlation matrix or null\n\t*/\n\tfunction accumulator1( v ) {\n\t\tvar denom;\n\t\tvar rdx;\n\t\tvar cij;\n\t\tvar rij;\n\t\tvar sdi;\n\t\tvar di;\n\t\tvar vi;\n\t\tvar m;\n\t\tvar n;\n\t\tvar r;\n\t\tvar i;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn corr;\n\t\t}\n\t\tif ( !isVectorLike( v ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Must provide a one-dimensional ndarray. Value: `%s`.', v ) );\n\t\t}\n\t\tif ( v.shape[ 0 ] !== order ) {\n\t\t\tthrow new Error( format( 'invalid argument. Vector length must match correlation matrix dimensions. Expected: `%u`. Actual: `%u`.', order, v.shape[ 0 ] ) );\n\t\t}\n\t\tn = N;\n\t\tN += 1;\n\t\tr = n / N;\n\n\t\tdenom = n || 1; // Bessel's correction (avoiding divide-by-zero below)\n\n\t\tif ( N === 1 ) {\n\t\t\tfor ( i = 0; i < order; i++ ) {\n\t\t\t\tvi = v.get( i );\n\t\t\t\tm = mu.get( i );\n\n\t\t\t\t// Compute the residual:\n\t\t\t\tdi = vi - m;\n\n\t\t\t\t// Update the sample mean:\n\t\t\t\tm += di / N;\n\t\t\t\tmu.set( i, m );\n\n\t\t\t\t// Update the sample standard deviation:\n\t\t\t\td[ i ] = di;\n\t\t\t\tM2[ i ] += di * ( vi-m );\n\t\t\t\tsd[ i ] = sqrt( M2[i]/denom );\n\n\t\t\t\t// Update the co-moments and correlation matrix, recognizing that the matrices are symmetric...\n\t\t\t\trdx = r * d[i]; // if `n=0`, `r=0.0`\n\t\t\t\tfor ( j = 0; j < i; j++ ) {\n\t\t\t\t\tcij = C.get( i, j ) + ( rdx*d[j] );\n\t\t\t\t\tC.set( i, j, cij );\n\t\t\t\t\tC.set( j, i, cij ); // via symmetry\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i = 0; i < order; i++ ) {\n\t\t\t\tvi = v.get( i );\n\t\t\t\tm = mu.get( i );\n\n\t\t\t\t// Compute the residual:\n\t\t\t\tdi = vi - m;\n\n\t\t\t\t// Update the sample mean:\n\t\t\t\tm += di / N;\n\t\t\t\tmu.set( i, m );\n\n\t\t\t\t// Update the sample standard deviation:\n\t\t\t\td[ i ] = di;\n\t\t\t\tM2[ i ] += di * ( vi-m );\n\t\t\t\tsd[ i ] = sqrt( M2[i]/denom );\n\n\t\t\t\trdx = r * d[i];\n\t\t\t\tsdi = sd[ i ];\n\t\t\t\tfor ( j = 0; j < i; j++ ) {\n\t\t\t\t\tcij = C.get( i, j ) + ( rdx*d[j] );\n\t\t\t\t\tC.set( i, j, cij );\n\t\t\t\t\tC.set( j, i, cij ); // via symmetry\n\n\t\t\t\t\trij = ( cij/denom ) / ( sdi*sd[j] );\n\t\t\t\t\tcorr.set( i, j, rij );\n\t\t\t\t\tcorr.set( j, i, rij ); // via symmetry\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn corr;\n\t}\n\n\t/**\n\t* If provided a data vector, the accumulator function returns an updated sample correlation matrix. If not provided a data vector, the accumulator function returns the current sample correlation matrix.\n\t*\n\t* @private\n\t* @param {ndarray} [v] - data vector\n\t* @throws {TypeError} must provide a 1-dimensional ndarray\n\t* @throws {Error} vector length must match correlation matrix dimensions\n\t* @returns {(ndarray|null)} sample correlation matrix or null\n\t*/\n\tfunction accumulator2( v ) {\n\t\tvar rij;\n\t\tvar cij;\n\t\tvar sdi;\n\t\tvar di;\n\t\tvar i;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn corr;\n\t\t}\n\t\tif ( !isVectorLike( v ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Must provide a one-dimensional ndarray. Value: `%s`.', v ) );\n\t\t}\n\t\tif ( v.shape[ 0 ] !== order ) {\n\t\t\tthrow new Error( format( 'invalid argument. Vector length must match correlation matrix dimensions. Expected: `%u`. Actual: `%u`.', order, v.shape[ 0 ] ) );\n\t\t}\n\t\tN += 1;\n\t\tfor ( i = 0; i < order; i++ ) {\n\t\t\t// Compute the residual:\n\t\t\tdi = v.get( i ) - mu.get( i );\n\t\t\td[ i ] = di;\n\n\t\t\t// Update the standard deviation:\n\t\t\tM2[ i ] += di * di;\n\t\t\tsd[ i ] = sqrt( M2[i]/N );\n\n\t\t\t// Update the co-moments and correlation matrix, recognizing that the matrices are symmetric...\n\t\t\tsdi = sd[ i ];\n\t\t\tfor ( j = 0; j < i; j++ ) {\n\t\t\t\tcij = C.get( i, j ) + ( di*d[j] );\n\t\t\t\tC.set( i, j, cij );\n\t\t\t\tC.set( j, i, cij ); // via symmetry\n\n\t\t\t\trij = ( cij/N ) / ( sdi*sd[j] );\n\t\t\t\tcorr.set( i, j, rij );\n\t\t\t\tcorr.set( j, i, rij ); // via symmetry\n\t\t\t}\n\t\t}\n\t\treturn corr;\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = incrpcorrmat;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute a sample Pearson product-moment correlation matrix incrementally.\n*\n* @module @stdlib/stats-incr-pcorrmat\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n* var incrpcorrmat = require( '@stdlib/stats-incr-pcorrmat' );\n*\n* // Create an output correlation matrix:\n* var buffer = new Float64Array( 4 );\n* var shape = [ 2, 2 ];\n* var strides = [ 2, 1 ];\n* var offset = 0;\n* var order = 'row-major';\n*\n* var corr = ndarray( 'float64', buffer, shape, strides, offset, order );\n*\n* // Create a correlation matrix accumulator:\n* var accumulator = incrpcorrmat( corr );\n*\n* var out = accumulator();\n* // returns null\n*\n* // Create a data vector:\n* buffer = new Float64Array( 2 );\n* shape = [ 2 ];\n* strides = [ 1 ];\n*\n* var vec = ndarray( 'float64', buffer, shape, strides, offset, order );\n*\n* // Provide data to the accumulator:\n* vec.set( 0, 2.0 );\n* vec.set( 1, 1.0 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* var bool = ( out === corr );\n* // returns true\n*\n* vec.set( 0, -5.0 );\n* vec.set( 1, 3.14 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* // Retrieve the correlation matrix:\n* out = accumulator();\n* // returns <ndarray>\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAoB,QAAS,oCAAqC,EAAE,YACpEC,EAAiB,QAAS,iCAAkC,EAC5DC,EAAe,QAAS,+BAAgC,EACxDC,EAAe,QAAS,uBAAwB,EAChDC,EAAS,QAAS,uBAAwB,EAC1CC,EAAO,QAAS,gCAAiC,EACjDC,EAAO,QAAS,sBAAuB,EACvCC,EAAQ,QAAS,2BAA4B,EAC7CC,EAAQ,QAAS,4BAA6B,EAalD,SAASC,EAAcC,EAAGC,EAAO,CAChC,IAAIC,EACAC,EACAC,EACAC,EAEJ,OAAKJ,EACJI,EAAIR,EAEJQ,EAAIT,EAELO,EAAS,IAAIV,EAAcO,EAAEA,CAAE,EAC/BI,EAAQ,CAAEJ,EAAGA,CAAE,EACfE,EAAU,CAAEF,EAAG,CAAE,EACVK,EAAG,UAAWF,EAAQC,EAAOF,EAAS,EAAG,WAAY,CAC7D,CAUA,SAASI,EAAUC,EAAQC,EAAI,CAC9B,IAAIC,EAAIF,EAAO,MAAO,CAAE,EACpBG,EACJ,IAAMA,EAAI,EAAGA,EAAID,EAAGC,IACnBH,EAAO,IAAKG,EAAGA,EAAGF,CAAE,EAErB,OAAOD,CACR,CASA,SAASI,EAAcC,EAAI,CAC1B,IAAIV,EACAC,EACAC,EAEJ,OAAAD,EAAS,IAAIV,EAAcmB,CAAE,EAC7BR,EAAQ,CAAEQ,CAAE,EACZV,EAAU,CAAE,CAAE,EAEPL,EAAO,UAAWM,EAAQC,EAAOF,EAAS,EAAG,WAAY,CACjE,CAoKA,SAASW,EAAcC,EAAKC,EAAQ,CACnC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAV,EAGJ,GADAA,EAAI,EACCtB,EAAmBwB,CAAI,EAC3BE,EAAQF,EACRG,EAAOlB,EAAciB,EAAO,EAAM,UACvBzB,EAAgBuB,CAAI,EAC/BE,EAAQF,EAAI,MAAO,CAAE,EACrBG,EAAOH,MAEP,OAAM,IAAI,UAAWpB,EAAQ,mLAAoLoB,CAAI,CAAE,EAiBxN,GAdAG,EAAOX,EAAUW,EAAM,CAAI,EAG3BK,EAAI,IAAI7B,EAAcuB,CAAM,EAG5BE,EAAK,IAAIzB,EAAcuB,CAAM,EAG7BG,EAAK,IAAI1B,EAAcuB,CAAM,EAG7BK,EAAItB,EAAciB,EAAO,EAAK,EAEzB,UAAU,OAAS,EAAI,CAC3B,GAAK,CAACxB,EAAcuB,CAAM,EACzB,MAAM,IAAI,UAAWrB,EAAQ,oFAAqFqB,CAAM,CAAE,EAE3H,GAAKjB,EAAOiB,EAAM,KAAM,IAAMC,EAC7B,MAAM,IAAI,MAAO,+HAA+HA,EAAM,aAAalB,EAAOiB,EAAM,KAAM,EAAE,GAAI,EAE7L,OAAAK,EAAKL,EACEQ,CACR,CAEA,OAAAH,EAAKT,EAAcK,CAAM,EAElBQ,EAWP,SAASA,EAAchB,EAAI,CAC1B,IAAIiB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAhC,EACAiC,EACAvB,EACAwB,EACJ,GAAK,UAAU,SAAW,EACzB,OAAKtB,IAAM,EACH,KAEDK,EAER,GAAK,CAACzB,EAAcgB,CAAE,EACrB,MAAM,IAAI,UAAWd,EAAQ,yEAA0Ec,CAAE,CAAE,EAE5G,GAAKA,EAAE,MAAO,CAAE,IAAMQ,EACrB,MAAM,IAAI,MAAOtB,EAAQ,0GAA2GsB,EAAOR,EAAE,MAAO,CAAE,CAAE,CAAE,EAQ3J,GANAR,EAAIY,EACJA,GAAK,EACLqB,EAAIjC,EAAIY,EAERa,EAAQzB,GAAK,EAERY,IAAM,EACV,IAAMF,EAAI,EAAGA,EAAIM,EAAON,IAkBvB,IAjBAqB,EAAKvB,EAAE,IAAKE,CAAE,EACdsB,EAAIZ,EAAG,IAAKV,CAAE,EAGdoB,EAAKC,EAAKC,EAGVA,GAAKF,EAAKlB,EACVQ,EAAG,IAAKV,EAAGsB,CAAE,EAGbV,EAAGZ,CAAE,EAAIoB,EACTZ,EAAIR,CAAE,GAAKoB,GAAOC,EAAGC,GACrBb,EAAIT,CAAE,EAAIf,EAAMuB,EAAGR,CAAC,EAAEe,CAAM,EAG5BC,EAAMO,EAAIX,EAAEZ,CAAC,EACPwB,EAAI,EAAGA,EAAIxB,EAAGwB,IACnBP,EAAMN,EAAE,IAAKX,EAAGwB,CAAE,EAAMR,EAAIJ,EAAEY,CAAC,EAC/Bb,EAAE,IAAKX,EAAGwB,EAAGP,CAAI,EACjBN,EAAE,IAAKa,EAAGxB,EAAGiB,CAAI,MAInB,KAAMjB,EAAI,EAAGA,EAAIM,EAAON,IAkBvB,IAjBAqB,EAAKvB,EAAE,IAAKE,CAAE,EACdsB,EAAIZ,EAAG,IAAKV,CAAE,EAGdoB,EAAKC,EAAKC,EAGVA,GAAKF,EAAKlB,EACVQ,EAAG,IAAKV,EAAGsB,CAAE,EAGbV,EAAGZ,CAAE,EAAIoB,EACTZ,EAAIR,CAAE,GAAKoB,GAAOC,EAAGC,GACrBb,EAAIT,CAAE,EAAIf,EAAMuB,EAAGR,CAAC,EAAEe,CAAM,EAE5BC,EAAMO,EAAIX,EAAEZ,CAAC,EACbmB,EAAMV,EAAIT,CAAE,EACNwB,EAAI,EAAGA,EAAIxB,EAAGwB,IACnBP,EAAMN,EAAE,IAAKX,EAAGwB,CAAE,EAAMR,EAAIJ,EAAEY,CAAC,EAC/Bb,EAAE,IAAKX,EAAGwB,EAAGP,CAAI,EACjBN,EAAE,IAAKa,EAAGxB,EAAGiB,CAAI,EAEjBC,EAAQD,EAAIF,GAAYI,EAAIV,EAAGe,CAAC,GAChCjB,EAAK,IAAKP,EAAGwB,EAAGN,CAAI,EACpBX,EAAK,IAAKiB,EAAGxB,EAAGkB,CAAI,EAIvB,OAAOX,CACR,CAWA,SAASM,EAAcf,EAAI,CAC1B,IAAIoB,EACAD,EACAE,EACAC,EACA,EACAI,EACJ,GAAK,UAAU,SAAW,EACzB,OAAKtB,IAAM,EACH,KAEDK,EAER,GAAK,CAACzB,EAAcgB,CAAE,EACrB,MAAM,IAAI,UAAWd,EAAQ,yEAA0Ec,CAAE,CAAE,EAE5G,GAAKA,EAAE,MAAO,CAAE,IAAMQ,EACrB,MAAM,IAAI,MAAOtB,EAAQ,0GAA2GsB,EAAOR,EAAE,MAAO,CAAE,CAAE,CAAE,EAG3J,IADAI,GAAK,EACC,EAAI,EAAG,EAAII,EAAO,IAWvB,IATAc,EAAKtB,EAAE,IAAK,CAAE,EAAIY,EAAG,IAAK,CAAE,EAC5BE,EAAG,CAAE,EAAIQ,EAGTZ,EAAI,CAAE,GAAKY,EAAKA,EAChBX,EAAI,CAAE,EAAIxB,EAAMuB,EAAG,CAAC,EAAEN,CAAE,EAGxBiB,EAAMV,EAAI,CAAE,EACNe,EAAI,EAAGA,EAAI,EAAGA,IACnBP,EAAMN,EAAE,IAAK,EAAGa,CAAE,EAAMJ,EAAGR,EAAEY,CAAC,EAC9Bb,EAAE,IAAK,EAAGa,EAAGP,CAAI,EACjBN,EAAE,IAAKa,EAAG,EAAGP,CAAI,EAEjBC,EAAQD,EAAIf,GAAQiB,EAAIV,EAAGe,CAAC,GAC5BjB,EAAK,IAAK,EAAGiB,EAAGN,CAAI,EACpBX,EAAK,IAAKiB,EAAG,EAAGN,CAAI,EAGtB,OAAOX,CACR,CACD,CAKA5B,EAAO,QAAUwB,ICpYjB,IAAIsB,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isPositiveInteger", "isSquareMatrix", "isVectorLike", "Float64Array", "format", "sqrt", "ctor", "bctor", "numel", "createMatrix", "n", "bool", "strides", "buffer", "shape", "f", "diagonal", "matrix", "v", "M", "i", "createVector", "N", "incrpcorrmat", "out", "means", "order", "corr", "M2", "sd", "mu", "C", "d", "accumulator2", "accumulator1", "denom", "rdx", "cij", "rij", "sdi", "di", "vi", "m", "r", "j", "main"]
}
